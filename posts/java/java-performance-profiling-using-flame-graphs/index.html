<!doctype html><html lang=en data-theme><head><title>Lei Zhang | Java Performance Profiling Using Flame Graphs</title><meta charset=utf-8><meta name=generator content="Hugo 0.110.0"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=description content="This is my knowledge base. I document things here"><link rel=stylesheet href=/css/style.min.7cf3c5090ac13256a5fa5531e5649cfe5a2ba7de88dca14ce0b6e253409a3511.css integrity="sha256-fPPFCQrBMlal+lUx5WSc/lorp96I3KFM4LbiU0CaNRE=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/css/markupHighlight.min.f798cbda9aaa38f89eb38be6414bd082cfd71a6780375cbf67b6d2fb2b96491e.css integrity="sha256-95jL2pqqOPies4vmQUvQgs/XGmeAN1y/Z7bS+yuWSR4=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/css/custom.min.3fa691134fafa8351e9d193939a352647c1ae886828bdefa3f5a272653dbf7e4.css integrity="sha256-P6aRE0+vqDUenRk5OaNSZHwa6IaCi976P1onJlPb9+Q=" crossorigin=anonymous media=screen><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css integrity="sha512-+4zCK9k+qNFUR5X+cKL9EIR+ZOhtIloNl9GIKS57V1MyNsYpYcUrUeQc9vNfzsWfV28IaLL3i96P9sdNyeRssA==" crossorigin=anonymous><link rel="shortcut icon" href=/favicons/favicon.ico type=image/x-icon><link rel=apple-touch-icon sizes=180x180 href=/favicons/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicons/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicons/favicon-16x16.png><link rel=canonical href=/posts/java/java-performance-profiling-using-flame-graphs/><script type=text/javascript src=/js/anatole-header.min.df804b63b5bd8474ea0756ea874bc8f1e92552708cc6ea43aa0d76981dc419f9.js integrity="sha256-34BLY7W9hHTqB1bqh0vI8eklUnCMxupDqg12mB3EGfk=" crossorigin=anonymous></script><meta name=twitter:card content="summary"><meta name=twitter:title content="Java Performance Profiling Using Flame Graphs"><meta name=twitter:description content="JDK 有很多性能测量工具 JConsole、VisualVM、HPROF 等。它们中的大多数将应用程序作为一个整体进行分析，并且需要一些繁琐的分析过程能到分析出类或方法级别的热点。
当我试图评估我们的一个服务的性能时，可以通过 CPU 火焰图的方法，它在找出代码的 CPU 使用率方面非常有效。
这篇文章记录了我在对投递服务进行基准测试时发现的性能问题，以及通过 CPU 火焰图找到热点方法并改进的调优过程。
要求 如果你使用 IntelliJ IDEA Ultimate ，那么这个 IDE 自带一个火焰图工具 Async Profiler 如果你要在生产环境生成火焰图，你可以借助这个工具 火焰图生成工具 async-profiler 场景 这一切源于一个基准测试。通常我们在交付一个产品前需要对这个服务进行基准测试。并通过基准测试结果得出在某些硬件基准下我们服务的性能指标，最终通过这些指标你可以回答用户提出的容量要求。
投递服务： 这个服务负责从客户端接收消息，放入待发送队列，并持久化到数据库中。然后立即返回给客户端。为了准确额模拟客户端我为此编写了一个基准测试客户端程序。
经过多轮基准测试，我们找到单机服务下了吞吐率最佳的参数，并得到了最佳吞吐率 QPS 769
总计发送 10000 笔业务 50 并发； Welcome to the Notifier CLI 4.8.0 Type 'help' for help. notifier>benchmark -T 123123 -n 10000 -c 50 -w 10 Benchmarking ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ Warm Up 10 Concurrency Level 50 Time taken for tests 13 seconds Complete requests 10000 Failed requests 5000 Refused requests 0 Requests per second 769 [#/sec] Time per request 67 [ms] Percentage of the requests served within a certain time (ms) 50% 46."></head><body><div class="sidebar ."><div class=logo-title><div class=title><img src=/images/profile.jpg alt="profile picture"><h3 title><a href=/>I'm Lei Zhang</a></h3><div class=description><p>This is my knowledge base. I document things here</p></div></div><p><a href=https://github.com/coolbeevip><img src="https://img.shields.io/github/followers/coolbeevip?label=follow&style=social" alt="GitHub coolbeevip"></a>
<img src=https://badges.pufler.dev/commits/all/coolbeevip alt="Commits Badge">
<img src=https://badges.pufler.dev/repos/coolbeevip alt="Repos Badge">
<img src=https://badges.pufler.dev/years/coolbeevip alt="Years Badge"></p></div><ul class=social-links><li><a href=https://github.com/coolbeevip/ rel=me aria-label=GitHub><i class="fab fa-github fa-2x" aria-hidden=true></i></a></li><li><a href=mailto:zhanglei@apache.org rel=me aria-label=e-mail><i class="fas fa-envelope fa-2x" aria-hidden=true></i></a></li></ul><div class=footer><div class=by_farbox>&copy; Lei Zhang 2023</div></div></div><div class=main><div class="page-top ."><a role=button class=navbar-burger data-target=navMenu aria-label=menu aria-expanded=false><span aria-hidden=true></span>
<span aria-hidden=true></span>
<span aria-hidden=true></span></a><ul class=nav id=navMenu><li><a href=/ title>Home</a></li><li><a href=/posts title>Blog</a></li><li><a href=/bookmarks title>Bookmarks</a></li><li><a href=/about/ title>About</a></li></ul></div><div class=autopagerize_page_element><div class=content><div class="post ."><div class=post-content><div class=post-title><h3>Java Performance Profiling Using Flame Graphs</h3></div><p>JDK 有很多性能测量工具 JConsole、VisualVM、HPROF 等。它们中的大多数将应用程序作为一个整体进行分析，并且需要一些繁琐的分析过程能到分析出类或方法级别的热点。</p><p>当我试图评估我们的一个服务的性能时，可以通过 CPU 火焰图的方法，它在找出代码的 CPU 使用率方面非常有效。</p><p>这篇文章记录了我在对投递服务进行基准测试时发现的性能问题，以及通过 CPU 火焰图找到热点方法并改进的调优过程。</p><h2 id=要求>要求</h2><ul><li>如果你使用 IntelliJ IDEA Ultimate ，那么这个 IDE 自带一个火焰图工具 <a href=https://www.jetbrains.com/help/idea/async-profiler.html>Async Profiler</a></li><li>如果你要在生产环境生成火焰图，你可以借助这个工具 <a href=https://github.com/jvm-profiling-tools/async-profiler>火焰图生成工具 async-profiler</a></li></ul><h2 id=场景>场景</h2><p>这一切源于一个基准测试。通常我们在交付一个产品前需要对这个服务进行基准测试。并通过基准测试结果得出在某些硬件基准下我们服务的性能指标，最终通过这些指标你可以回答用户提出的容量要求。</p><p><strong>投递服务：</strong> 这个服务负责从客户端接收消息，放入待发送队列，并持久化到数据库中。然后立即返回给客户端。为了准确额模拟客户端我为此编写了一个基准测试客户端程序。</p><p>经过多轮基准测试，我们找到单机服务下了吞吐率最佳的参数，并得到了最佳吞吐率 QPS 769</p><ul><li>总计发送 10000 笔业务</li><li>50 并发；</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Welcome to the Notifier CLI 4.8.0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Type <span style=color:#e6db74>&#39;help&#39;</span> <span style=color:#66d9ef>for</span> help.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>notifier&gt;benchmark -T <span style=color:#ae81ff>123123</span> -n <span style=color:#ae81ff>10000</span> -c <span style=color:#ae81ff>50</span> -w <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>Benchmarking ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Warm Up                   <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>Concurrency Level         <span style=color:#ae81ff>50</span>
</span></span><span style=display:flex><span>Time taken <span style=color:#66d9ef>for</span> tests      <span style=color:#ae81ff>13</span> seconds
</span></span><span style=display:flex><span>Complete requests         <span style=color:#ae81ff>10000</span>
</span></span><span style=display:flex><span>Failed requests           <span style=color:#ae81ff>5000</span>
</span></span><span style=display:flex><span>Refused requests          <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>Requests per second       <span style=color:#ae81ff>769</span> <span style=color:#f92672>[</span><span style=color:#75715e>#/sec]</span>
</span></span><span style=display:flex><span>Time per request          <span style=color:#ae81ff>67</span> <span style=color:#f92672>[</span>ms<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Percentage of the requests served within a certain time <span style=color:#f92672>(</span>ms<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>50%   46.32
</span></span><span style=display:flex><span>60%   46.46
</span></span><span style=display:flex><span>70%   44.75
</span></span><span style=display:flex><span>80%   41.13
</span></span><span style=display:flex><span>90%   36.82
</span></span><span style=display:flex><span>100%  33.14
</span></span><span style=display:flex><span>Done.
</span></span><span style=display:flex><span>notifier&gt;
</span></span></code></pre></div><p><strong>因为我们的客户端和服务端通过 GRPC 协议进行通信，并且服务端只做消息入队列和持久化到数据库，理论上 QPS 至少应该达到 1000</strong></p><h2 id=分析-intellij-idea-ultimate>分析 (IntelliJ IDEA Ultimate)</h2><p>因为在 IntelliJ IDEA Ultimate 中生成火焰图比较方便，所以我直接使用 Async Profiler 插件，重做一次基准测试并生成如下火焰图</p><p><img src=/images/posts/java/java-performance-profiling-using-flame-graphs/notifier-cpu-flame-before.png alt=notifier-cpu-flame-before></p><p>火焰图的 X 轴记录了整体消耗的时间，你可以发现 <strong>NotifierMessage.uniqueId()</strong> 方法消耗了总时间的 15.23 %</p><p>找到对应代码，发现这个方法使用了 MD5 生成消息的唯一标识</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>uniqueId</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  String value <span style=color:#f92672>=</span> content <span style=color:#f92672>+</span> smsTo <span style=color:#f92672>+</span> sourceAddrSuffix<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> md5<span style=color:#f92672>(</span>value<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span> String <span style=color:#a6e22e>md5</span><span style=color:#f92672>(</span>String value<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    MessageDigest md <span style=color:#f92672>=</span> MessageDigest<span style=color:#f92672>.</span><span style=color:#a6e22e>getInstance</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;MD5&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    md<span style=color:#f92672>.</span><span style=color:#a6e22e>update</span><span style=color:#f92672>(</span>value<span style=color:#f92672>.</span><span style=color:#a6e22e>getBytes</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> digest <span style=color:#f92672>=</span> md<span style=color:#f92672>.</span><span style=color:#a6e22e>digest</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> DatatypeConverter<span style=color:#f92672>.</span><span style=color:#a6e22e>printHexBinary</span><span style=color:#f92672>(</span>digest<span style=color:#f92672>).</span><span style=color:#a6e22e>toUpperCase</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>Exception ex<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> RuntimeException<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;MD5失败&#34;</span><span style=color:#f92672>,</span> ex<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h2 id=优化>优化</h2><p>众所周知 MD5 是安全性较高的摘要算法，但是极限测试时性能问题比较突出，因为我们从业务上生成这个唯一ID，只是为了做短期（1分钟之内）的消息重复判定，所以我们可以改为 CRC32 摘要算法（我用 <a href=https://github.com/openjdk/jmh>JMH</a> 简单做了 CRC32 和 MD5 的基准测试 ，发现 CRC32 性能高很多）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>uniqueId</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  String value <span style=color:#f92672>=</span> content <span style=color:#f92672>+</span> smsTo <span style=color:#f92672>+</span> sourceAddrSuffix<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> checksum<span style=color:#f92672>(</span>value<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span> String <span style=color:#a6e22e>checksum</span><span style=color:#f92672>(</span>String value<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  Checksum crc32 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> CRC32<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>  crc32<span style=color:#f92672>.</span><span style=color:#a6e22e>update</span><span style=color:#f92672>(</span>value<span style=color:#f92672>.</span><span style=color:#a6e22e>getBytes</span><span style=color:#f92672>(),</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>,</span> value<span style=color:#f92672>.</span><span style=color:#a6e22e>getBytes</span><span style=color:#f92672>().</span><span style=color:#a6e22e>length</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> String<span style=color:#f92672>.</span><span style=color:#a6e22e>valueOf</span><span style=color:#f92672>(</span>crc32<span style=color:#f92672>.</span><span style=color:#a6e22e>getValue</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>修改完毕后我们重新做基准测试，可以看到吞吐率提升到 QPS 1428，相比于优化前提升了 <strong>100%</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Welcome to the Notifier CLI 4.1.0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Type <span style=color:#e6db74>&#39;help&#39;</span> <span style=color:#66d9ef>for</span> help.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>notifier&gt;benchmark -T <span style=color:#ae81ff>123123</span> -n <span style=color:#ae81ff>10000</span> -c <span style=color:#ae81ff>50</span> -w <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>Benchmarking ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Warm Up                   <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>Concurrency Level         <span style=color:#ae81ff>50</span>
</span></span><span style=display:flex><span>Time taken <span style=color:#66d9ef>for</span> tests      <span style=color:#ae81ff>7</span> seconds
</span></span><span style=display:flex><span>Complete requests         <span style=color:#ae81ff>10000</span>
</span></span><span style=display:flex><span>Failed requests           <span style=color:#ae81ff>5000</span>
</span></span><span style=display:flex><span>Refused requests          <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>Requests per second       <span style=color:#ae81ff>1428</span> <span style=color:#f92672>[</span><span style=color:#75715e>#/sec]</span>
</span></span><span style=display:flex><span>Time per request          <span style=color:#ae81ff>38</span> <span style=color:#f92672>[</span>ms<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Percentage of the requests served within a certain time <span style=color:#f92672>(</span>ms<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>50%   19.41
</span></span><span style=display:flex><span>60%   18.19
</span></span><span style=display:flex><span>70%   16.48
</span></span><span style=display:flex><span>80%   14.81
</span></span><span style=display:flex><span>90%   13.25
</span></span><span style=display:flex><span>100%  11.93
</span></span><span style=display:flex><span>Done.
</span></span><span style=display:flex><span>notifier&gt;
</span></span></code></pre></div><p>优化后的火焰图可以看到，处理 10000 比请求中 NotifierMessage.uniqueId() 方法的总耗时从 <strong>15.23%</strong> 下降到了 <strong>4.34%</strong></p><p><img src=/images/posts/java/java-performance-profiling-using-flame-graphs/notifier-cpu-flame-after.png alt=notifier-cpu-flame-after></p><h2 id=在服务器上生成火焰图>在服务器上生成火焰图</h2><p>你可以直接下载 <a href=https://github.com/jvm-profiling-tools/async-profiler>Async Profiler</a> 工具，抓取服务器上对应 PID 的服务火焰图</p><p>例如：监控 PID 进程 30 秒，并生成火焰图文件 cpu.html</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>./profiler.sh -d <span style=color:#ae81ff>30</span> -f cpu.html &lt;pid&gt;
</span></span></code></pre></div><p><img src=/images/posts/java/java-performance-profiling-using-flame-graphs/async-profiler.png alt=notifier-cpu-flame-before></p><ul><li>绿⾊：代表java执⾏的代码 (主要)</li><li>黄色：代表 C/C++ ⼀类的 Native 代码, 包括编译器 GC 执⾏ (次要)</li><li>红色：代表系统调⽤层, 或是未知的执⾏代码段</li></ul><h2 id=引用>引用</h2><ul><li><a href=https://www.brendangregg.com/Slides/JavaOne2016_JavaFlameGraphs.pdf>Java Performance Analysis on Linux with Flame Graphs</a></li><li><a href=https://www.brendangregg.com/blog/2016-09-28/java-warmup.html>Brendan Gregg&rsquo;s Blog Java Warmup</a></li></ul></div><div class=post-footer><div class=info><span class=separator><a class=category href=/categories/java/>java</a></span>
<span class=separator><a class=tag href=/tags/jvm/>jvm</a><a class=tag href=/tags/proformancee/>proformancee</a></span></div></div></div></div></div></div><script type=text/javascript src=/js/medium-zoom.min.e1c6918cbaa90022a5612f0bd71c7bf3be6d036614c5729cebfe14f7b91fa4bc.js integrity="sha256-4caRjLqpACKlYS8L1xx7875tA2YUxXKc6/4U97kfpLw=" crossorigin=anonymous></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.css integrity=sha384-t5CR+zwDAROtph0PXGte6ia8heboACF9R5l/DiY+WZ3P2lxNgvJkQk5n7GPvLMYw crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.js integrity=sha384-FaFLTlohFghEIZkw6VGwmf9ISTubWAVYW8tG8+w2LAIftJEULZABrF9PPFv+tVkH crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/contrib/auto-render.min.js integrity=sha384-bHBqxz8fokvgoJ/sc17HODNxa42TlaEhB+w8ZJXTc2nZf1VgEaFZeZvT4Mznfz0v crossorigin=anonymous onload=renderMathInElement(document.body)></script></body></html>