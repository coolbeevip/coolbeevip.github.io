<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>approximate on</title><link>https://coolbeevip.github.io/tags/approximate/</link><description>Recent content in approximate on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 20 Aug 2021 13:24:14 +0800</lastBuildDate><atom:link href="https://coolbeevip.github.io/tags/approximate/index.xml" rel="self" type="application/rss+xml"/><item><title>Approximate counting algorithm(Morris) Java</title><link>https://coolbeevip.github.io/posts/algorithm/morris-approximate-counter/</link><pubDate>Fri, 20 Aug 2021 13:24:14 +0800</pubDate><guid>https://coolbeevip.github.io/posts/algorithm/morris-approximate-counter/</guid><description>本文介绍如何使用莫里斯计数器（近似计数算法）的 Java 实现 ，莫里斯计数器采用概率计数原理，用很小的内存实现海量数据的近似计数。
本例中，我们使用一个 byte (8bit) 的变量，实现千万级的计数
public class MorrisApproximateCounter { private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass()); /** * 定义一个计数器变量 */ byte counter = 0; /** * 使用随机模拟概率 */ Random random = new Random(); /** * 计算计数器表示的近似值 */ public double get() { return Math.exp(counter); } /** * 计数器累加 */ public void increment() { double probability = 1.0 / this.get(); // 使用伪随机数增加概率 if (random.nextDouble() &amp;lt; probability) { this.counter++; } } public static void main(String[] args) { MorrisApproximateCounter mc = new MorrisApproximateCounter(); // 定义实际数量 int realCount = 20_000_000; for (int n = 0; n &amp;lt; realCount; n++) { // 累加计数 mc.</description></item></channel></rss>