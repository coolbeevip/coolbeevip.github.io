<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>counter on</title><link>https://coolbeevip.github.io/tags/counter/</link><description>Recent content in counter on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 21 Aug 2021 00:24:14 +0800</lastBuildDate><atom:link href="https://coolbeevip.github.io/tags/counter/index.xml" rel="self" type="application/rss+xml"/><item><title>Approximate Counting Morris Algorithm in Java</title><link>https://coolbeevip.github.io/posts/algorithm/algorithm-morris-approximate-counter/</link><pubDate>Sat, 21 Aug 2021 00:24:14 +0800</pubDate><guid>https://coolbeevip.github.io/posts/algorithm/algorithm-morris-approximate-counter/</guid><description>这是一个莫里斯计数器（近似计数算法）的 Java 实现，用很小的数据结构准确估计具有几十亿数据量的数据计数。
我们通常会定义一个 Long 类型对象，通过累加的方式实现计数。每个 Long 类型占用 8 byte 空间，如果你有 30 亿个要记录的对象，那么你就需要 22GB 的空间存储这些计数器，这还不不包括在哈希中的对象ID。
例如我们记录网页的访问数量，并给出热点排名，如果我们面对的是每天有数十亿的访问场景，那么十亿和十亿零几千万差别并不大。这时我们往往不需要精确计数，如果我们只需要得到计数的近似值，并且使用一个小的数据结构( 例如 1 byte) 作为计数器，那么我们只需要大概 2GB 的空间就足够了。
以下样例代码中，我们使用 1 byte (8bit) 的变量，实现千万级的计数
public class MorrisApproximateCounter { private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass()); /** * 定义一个计数器变量 */ byte counter = 0; /** * 使用随机模拟概率 */ Random random = new Random(); /** * 计算计数器表示的近似值 */ public double get() { return Math.exp(counter); } /** * 计数器累加 */ public void increment() { double probability = 1.</description></item></channel></rss>