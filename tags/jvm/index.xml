<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>jvm on</title><link>https://coolbeevip.github.io/tags/jvm/</link><description>Recent content in jvm on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 12 Mar 2022 13:24:14 +0800</lastBuildDate><atom:link href="https://coolbeevip.github.io/tags/jvm/index.xml" rel="self" type="application/rss+xml"/><item><title>Java Performance Profiling Using Flame Graphs</title><link>https://coolbeevip.github.io/posts/java/java-performance-profiling-using-flame-graphs/</link><pubDate>Sat, 12 Mar 2022 13:24:14 +0800</pubDate><guid>https://coolbeevip.github.io/posts/java/java-performance-profiling-using-flame-graphs/</guid><description>JDK 有很多性能测量工具 JConsole、VisualVM、HPROF 等。它们中的大多数将应用程序作为一个整体进行分析，并且需要一些繁琐的分析过程能到分析出类或方法级别的热点。 当我试图评估我们的一个服务的性能时，可以通过到一种火焰图的方法，它在找出代码的 CPU 使用率方面非常有效。 这篇文章记录了我在对投递服务进行基准测试时发现的性能问题，以及通过 CPU 火焰图找到热点方法并改进的调优过程。
要求 如果你使用 IntelliJ IDEA Ultimate ，那么这个 IDE 自带一个火焰图工具 Async Profiler 如果你要在生产环境生成火焰图，你可以借助这个工具 火焰图生成工具 async-profiler 场景 这一切源于一个基准测试。通常我们在交付一个产品前需要对这个服务进行基准测试。并通过基准测试结果得出在某些硬件基准下我们服务的性能指标，最终通过这些指标你可以回答用户提出的容量要求。
投递服务： 这个服务负责从客户端接收消息，放入待发送队列，并持久化到数据库中。然后立即返回给客户端。为了准确额模拟客户端我为此编写了一个基准测试客户端程序。
经过多轮基准测试，我们找到单机服务下了吞吐率最佳的参数，并得到了最佳吞吐率 QPS 769
总计发送 10000 笔业务 50 并发； Welcome to the Notifier CLI 4.8.0 Type &amp;#39;help&amp;#39; for help. notifier&amp;gt;benchmark -T 123123 -n 10000 -c 50 -w 10 Benchmarking ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ Warm Up 10 Concurrency Level 50 Time taken for tests 13 seconds Complete requests 10000 Failed requests 5000 Refused requests 0 Requests per second 769 [#/sec] Time per request 67 [ms] Percentage of the requests served within a certain time (ms) 50% 46.</description></item><item><title>Important JVM Options</title><link>https://coolbeevip.github.io/posts/java/java-jvm-options/</link><pubDate>Tue, 06 Aug 2019 13:24:14 +0800</pubDate><guid>https://coolbeevip.github.io/posts/java/java-jvm-options/</guid><description>Heap Memory -XX:MetaspaceSize Metaspace 空间初始大小，如果不设置的话，默认是20.79M。这个初始大小是触发首次 Metaspace Full GC 的阈值，例如 -XX:MetaspaceSize=128M
-XX:MaxMetaspaceSize Metaspace 最大值，默认不限制大小，但是线上环境建议设置，例如 -XX:MaxMetaspaceSize=512M
GC -Xnoclassgc 表示关闭JVM对类的垃圾回收，缺省情况下，当一个类没有任何活动实例时，JVM 就会从内存中卸装该类，但是这样会使性能下降。如果关闭类垃圾回收，就可以消除由于多次装入和卸装同一个类而造成的开销
-XX:+UseParNewGC 设置年轻代为并行收集
-XX:MaxTenuringThreshold 控制新生代需要经历多少次GC​晋升到老年代中的最大阈值，默认值 15
-XX:+CMSParallelRemarkEnabled CMS收集算法步骤如下：初始标记 -&amp;gt; 并发标记 -&amp;gt; 重新标记 -&amp;gt; 标记清除。 其中 初始标记和重新标记都需要STW，即暂停用户线程。 CMSParallelRemarkEnabled参数可以让重新标记阶段进行并行重新标记，减少暂停时间
-XX:SurvivorRatio 设置 Eden、S0、S1 分配比例，默认值是 8
-XX:SurvivorRatio=5 表示 Eden 占 50%，S0、S1 平分剩余空间
-XX:+UseCompressedOops In short, don&amp;rsquo;t turn it on, use a version which has it on by default.
https://stackoverflow.com/questions/11054548/what-does-the-usecompressedoops-jvm-flag-do-and-when-should-i-use-it
-XX:+DisableExplicitGC 禁止 System.gc() 触发 GC 操作，当没有开启 DisableExplicitGC 这个参数时,你会发现JVM每个小时会执行一次Full GC,这是因为JVM在做分布式GC,为RMI服务的, 可以通过 sun.</description></item></channel></rss>