<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>algorithm on</title><link>https://coolbeevip.github.io/categories/algorithm/</link><description>Recent content in algorithm on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 22 Aug 2021 00:24:14 +0800</lastBuildDate><atom:link href="https://coolbeevip.github.io/categories/algorithm/index.xml" rel="self" type="application/rss+xml"/><item><title>Approximate Counting Morris Algorithm in Java</title><link>https://coolbeevip.github.io/posts/algorithm/algorithm-morris-approximate-counter/</link><pubDate>Sun, 22 Aug 2021 00:24:14 +0800</pubDate><guid>https://coolbeevip.github.io/posts/algorithm/algorithm-morris-approximate-counter/</guid><description>这是一个 Morris 计数器（近似计数算法）的 Java 实现，用很小的数据结构准确估计具有几十亿数据量的数据计数。 我们通常会定义一个 Long 类型对象，通过累加的方式实现计数。每个 Long 类型占用 8 byte (64bit) 空间，如果你有 30 亿个要记录的对象，那么你就需要 22GB 的空间存储这些计数器，这还不不包括在哈希中的对象ID。
背景 近似计数算法是允许我们使用非常少量的内存对大量事件进行计数的技术。它由 Robert Morris 于 1977 年发明。 该算法使用概率技术来增加计数器，尽管它不能保证准确性，但它确实提供了对真实值的相当好的估计，同时引入了最小但相当恒定的相对误差。 在这篇文章中，我们详细介绍了 Morris 算法及其背后的数学原理。
Morris 在贝尔实验室工作时遇到了一个问题。他应该编写一段代码来计算大量事件，而他只有一个 8 位计数器。 由于事件的数量很容易超过 256，使用普通方法计算它们是不可行的，这种限制导致他构建了这个近似计数器，它不是提供精确计数，而是提供一个近似计数。
计数和投硬币 构建近似计数器的一个简单方案是对每次事件变换进行计数。每收到一个新事件，我们抛一次硬币，如果正面朝上，我们增加计数，否则不增加。 这样计数器中的值平均下来将代表总事件的一半（因为抛硬币的获得正面并的概率是 0.5）。当我们将计数乘以 2 时，我们将得到近似实际数量的计数。
CoinFlipsCounter.java
这种基于抛硬币的计数技术是参数为 (n, p) 的二项分布，其中 n 是所见事件的总数，p 是成功概率，即在抛硬币过程中出现正面的概率。对真实事件数 n 的计数值 v 由下式给出
$$ \large 估算值v = 实际值n * 概率p = 实际值n/2 $$
这种二项式的正态分布标准偏差将帮助我们找到估算中的误差，对于正态分布平均值两侧标准差的两倍覆盖了分布的 95%；我们使用它来查找计数器值中的相对和绝对误差。
$$ \large 误差 = \sqrt{实际值n * 概率p(1-概率p)} = \sqrt{估算值v/2} $$</description></item></channel></rss>