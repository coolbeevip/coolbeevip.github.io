<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Git on</title><link>https://coolbeevip.github.io/categories/git/</link><description>Recent content in Git on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 17 Jul 2024 20:24:14 +0800</lastBuildDate><atom:link href="https://coolbeevip.github.io/categories/git/index.xml" rel="self" type="application/rss+xml"/><item><title>使用 Git Assistant IntelliJ Commits 可视化洞察</title><link>https://coolbeevip.github.io/posts/git-assistant-intellij-plugin/git-assistant-commit-insights/</link><pubDate>Wed, 17 Jul 2024 20:24:14 +0800</pubDate><guid>https://coolbeevip.github.io/posts/git-assistant-intellij-plugin/git-assistant-commit-insights/</guid><description>Git Assistant 插件是一个功能强大的 IntelliJ IDEA 插件，自 1.4.0 版本以来，新增了 Commits 可视化洞察功能。通过右侧工具窗口中的 Git Assistant Insights 窗口为用户提供了一系列强大的分析工具。
Hour/Weekday/Month 功能能够根据小时、周、月来分析团队活动的时间分布情况，从而优化工作安排和任务分配。 Timezone 功能可以可视化展示代码贡献的时区分布情况，使全球团队的协作变得可见可感。 在左侧的项目树中还提供了热点文件和热点目录的分析功能，帮助开发者更好地了解项目最近哪些文件和目录发生了较多的变更。 安装 Git Assistant 插件 首先，你需要在 IntelliJ IDEA 中安装 Git Assistant 插件。你可以通过 IntelliJ IDEA 的插件市场搜索 Git Assistant 并安装它。安装完毕后在右侧的 Git Assistant Insights 窗口中可以看到可视化统计信息
提交信息可视化洞察 在 Overview 面板可以展示代码库中贡献最多的开发者，有助于发现和表彰优秀贡献者，提升团队的协作和竞争力。
在 Hour/Weekday/Month 面板可以展示团队活动的时间分布情况，从而优化工作安排和任务分配。
在 Timezone 面板可以展示代码贡献的时区分布情况，使全球团队的协作变得可见可感。
在 Project View 面板可以展示热点文件和热点目录的分析功能，帮助开发者更好地了解项目最近哪些文件和目录发生了较多的变更。
结束语 你可以在 JetBrains Marketplace 上查看 Git Assistant 插件的详细信息并留下你的宝贵建议。</description></item><item><title>使用 Git Assistant IntelliJ 插件中的 AI 功能来生成提交信息</title><link>https://coolbeevip.github.io/posts/git-assistant-intellij-plugin/git-assistant-ai-commit-message/</link><pubDate>Wed, 17 Jul 2024 20:24:14 +0800</pubDate><guid>https://coolbeevip.github.io/posts/git-assistant-intellij-plugin/git-assistant-ai-commit-message/</guid><description>Git Assistant 插件是一个强大的 IntelliJ IDEA 插件，你可以通过配置自己的 OpenAI key 来使用其中的 AI 功能。在这篇文章中，我们将介绍如何使用 Git Assistant 插件中的 AI 功能来生成提交信息。
安装 Git Assistant 插件 首先，你需要在 IntelliJ IDEA 中安装 Git Assistant 插件。你可以通过 IntelliJ IDEA 的插件市场搜索 Git Assistant 并安装它。
配置 Git Assistant 插件 在安装完 Git Assistant 插件后，打开 Settings -&amp;gt; Plugins -&amp;gt; Tools -&amp;gt; Git Assistant 后可以看到如下配置界面。
OpenAI 配置 在这里你可以配置你的 OpenAI API host 和 OpenAI API key 后点击 Verify 按钮来验证你的配置是否正确。 通过点击 Refresh 按钮来刷新你可用的模型列表。最后点击 Apply 按钮来保存你的配置。
Global Prompt 配置 你可以在这里配置提示工程参数，用来控制生成的 commit message 的内容。</description></item><item><title>Automating Configuration Switching in Git with includeIf</title><link>https://coolbeevip.github.io/posts/git/git-automating-configuration-switching-with-includeif/</link><pubDate>Sun, 23 Jun 2024 13:24:14 +0800</pubDate><guid>https://coolbeevip.github.io/posts/git/git-automating-configuration-switching-with-includeif/</guid><description>在使用 Git 进行版本管理时，可以通过 includeif 语法在 Git 的配置文件中实现基于条件的配置自动切换。这特别适用于多账号管理场景，例如，当你在公司和家里使用不同的 Git 配置，包括用户名和电子邮件地址时，可以灵活地自动切换相关配置。
基本步骤 创建适用的本地配置文件: 对于不同的环墭（例如家里和公司），你需要分别创建独立的配置文件。例如，可以创建两个文件 gitconfig_home 和 gitconfig_work。
配置 gitconfig_home 和 gitconfig_work: 设置对应环境的用户名和邮箱等配置项。
gitconfig_home:
[user] name = Home User email = homeuser@example.com gitconfig_work:
[user] name = Work User email = workuser@example.com 修改全局 .gitconfig 文件: 你需要在全局 Git 配置文件中包含这些新创建的配置文件，但仅在符合特定条件时才包含它们。这可以通过 includeIf 指令实现。
编辑你的全局 Git 配置文件 (通常位于 ~/.gitconfig 或 ~/.config/git/config):
[includeIf &amp;#34;gitdir:~/work/&amp;#34;] path = ~/gitconfig_work [includeIf &amp;#34;gitdir:~/home/&amp;#34;] path = ~/gitconfig_home 这里的 gitdir 基于仓库的位置来决定使用哪个配置。例如，任何在 ~/work/ 目录下的 Git 仓库自动使用 gitconfig_work 中的配置。</description></item><item><title>Git filter-branch</title><link>https://coolbeevip.github.io/posts/git/git-command-filter-branch/</link><pubDate>Fri, 15 Sep 2023 13:24:14 +0800</pubDate><guid>https://coolbeevip.github.io/posts/git/git-command-filter-branch/</guid><description>使用 git filter-branch &amp;ndash;commit-filter 重写历史记录可能会导致数据丢失。这个命令允许你在Git存储库的历史记录中进行修改，应用一个自定义的 commit 过滤器。当你使用这个命令时，请务必小心操作，因为它会改变存储库的历史记录。
在执行前，建议先进行备份，以确保你有一个完好的历史记录备份。另外，这个命令可能会导致一些副作用，如更改提交哈希值、移除或合并提交、删除部分文件等。
因此，在执行 git filter-branch 之前，请确保你已经理解了它的工作原理，并且在执行前考虑了潜在的风险。如果你不确定自己在做什么，建议先创建一个分支进行实验，以避免意外破坏存储库的历史记录。
删除 README.md 和 docs/docker_build.md 两个文件，并清理所有产生的提交 git filter-branch --force --index-filter &amp;#39;git rm --cached --ignore-unmatch README.md docs/docker_build.md&amp;#39; --prune-empty --tag-name-filter cat -- --all 删除指定编号的提交信息 使用 git log --oneline 命令查询到要删除提交
git log --oneline | grep Update ed2e2a7 [feat]:[][Update docs/场景梳理.xlsx] 2a919eb [feat]:[][Update docs/场景梳理.xlsx] 记录要删除的提交短 ID 到以下脚本的 DEL_COMMIT_IDS=['ed2e2a7','a919eb'] 位置
git filter-branch --force --commit-filter &amp;#39;DEL_COMMIT_IDS=[&amp;#39;ed2e2a7&amp;#39;,&amp;#39;a919eb&amp;#39;]; if [[ $DEL_COMMIT_IDS =~ ${GIT_COMMIT:0:7} ]]; then skip_commit &amp;#34;$@&amp;#34;; else git commit-tree &amp;#34;$@&amp;#34;; fi&amp;#39; HEAD 执行后可以看到 Ref 'refs/heads/master' was rewritten 表示已经重写了历史记录，然后再用 git log --oneline 查看可以看到已经删除</description></item><item><title>Git Pick Commits to Another Reps</title><link>https://coolbeevip.github.io/posts/git/git-command-pick-commit-to-another-repsrepository/</link><pubDate>Sat, 18 Feb 2023 09:24:14 +0800</pubDate><guid>https://coolbeevip.github.io/posts/git/git-command-pick-commit-to-another-repsrepository/</guid><description>从上游仓库中选取 commits 提交到另一个仓库
附加修改作者，消息，时间
前期准备 你要准备一个要同步的库
# 下载这个库 git clone git@github.com:coolbeevip/git-commits-replay.git # 查看这个库的所有 commits git --git-dir=./git-commits-replay/.git log --pretty=format:&amp;#34;%H,%an,%ae,%ad,%s&amp;#34; --date=format:&amp;#39;%Y-%m-%d %H:%M:%S&amp;#39; --reverse 52d099240f6da63193ba309106dad77d060836a7,Lei Zhang,zhanglei@apache.org,2023-02-18 10:49:43,Create A.md 516e406615c0020919939bafe59b35359a03c33b,Lei Zhang,zhanglei@apache.org,2023-02-18 10:50:09,Create B.md 551e5c88440396b73f3b1642bf765dcb9136fd1f,Lei Zhang,zhanglei@apache.org,2023-02-18 10:50:30,Create C.md 5dacf876b6f0b4a0d3ead7ec3daaac924b1b37f4,Lei Zhang,zhanglei@apache.org,2023-02-18 10:51:02,Create ALL.md 72a7a54c48286e9a7c92d1201108baa61cbd7db4,Lei Zhang,zhanglei@apache.org,2023-02-18 10:52:13,删除 A B C 新建一个仓库并关联要同步的库
# 新建一个本地仓库 mkdir git-commits-replay-local cd git-commits-replay-local git init git config --global init.defaultBranch master git branch -m master # 关联上游仓库 git remote add upstream git@github.com:coolbeevip/git-commits-replay.git 重放 commit 并修改提交信息 例如要将 52d099240f6da63193ba309106dad77d060836a7,Lei Zhang,zhanglei@apache.</description></item><item><title>Awesome Git Aliases</title><link>https://coolbeevip.github.io/posts/git/git-awesome-aliases/</link><pubDate>Sat, 02 Apr 2022 13:24:14 +0800</pubDate><guid>https://coolbeevip.github.io/posts/git/git-awesome-aliases/</guid><description>我们可以通过别名定义简化命令输出，创造自己的命令
打开 ~/.gitconfig 文件您可以看到如下片段，在这个片段中我们可以为已有命令定义别名
[alias] 例如我们创建分支是需要使用 git branch -b xxx 命令，那么我们可以将 branch 简化为 br。我们只需要增加如下配置
[alias] br = branch 这是我自己常用的配置
[alias] ci = commit -a co = checkout cob = checkout -b cl = clone st = status br = branch mr = merge cp = cherry-pick hist = log --pretty=format:\&amp;#34;%h %ad | %s%d [%an]\&amp;#34; --graph --date=short type = cat-file -t dump = cat-file -p sync-up = !git fetch upstream &amp;amp;&amp;amp; git checkout $1 &amp;amp;&amp;amp; git rebase upstream/$1 &amp;amp;&amp;amp; git push origin $1 &amp;amp;&amp;amp; :</description></item><item><title>Awesome Git Hooks</title><link>https://coolbeevip.github.io/posts/git/git-awesome-hook/</link><pubDate>Sat, 02 Apr 2022 13:24:14 +0800</pubDate><guid>https://coolbeevip.github.io/posts/git/git-awesome-hook/</guid><description>commit-msg #!/bin/sh red=&amp;#39;\033[0;31m&amp;#39; green=&amp;#39;\033[0;32m&amp;#39; no_color=&amp;#39;\033[0m&amp;#39; commit_msg_file=&amp;#34;$1&amp;#34; commit_msg=$(cat &amp;#34;$commit_msg_file&amp;#34;) max_length=50 if [ ${#commit_msg} -gt $max_length ]; then echo &amp;#34;${red}信息长度不能超过50！${no_color}&amp;#34; exit 1 fi if [ &amp;#34;&amp;#34; = &amp;#34;$(grep -E &amp;#39;^(\[(fix|feat)\]:\[.*]\[.*\]|\[(docs|style|ref|test|chore|tag|revert|perf)\]:\[.*\])$&amp;#39; $1)&amp;#34; ]; then echo &amp;#34;${red}ERROR:${no_color} 你的提交描述格式错误, 请参考如下样例:&amp;#34; echo &amp;#34;${green}[feat]:[单号][新增XXXX]&amp;#34; echo &amp;#34;[feat]:[][新增XXXX]&amp;#34; echo &amp;#34;[fix]:[CRMAIF_ISSUE_XXX][修改/修复XXXX]&amp;#34; echo &amp;#34;[fix]:[][修改/修复XXXX]&amp;#34; echo &amp;#34;[docs]:[单号][新增/修订/删除XXXX]&amp;#34; echo &amp;#34;[docs]:[新增/修订/删除XXXX]&amp;#34; echo &amp;#34;[style]:[调整XX页XX格式]&amp;#34; echo &amp;#34;[ref]:[重构XXXX]&amp;#34; echo &amp;#34;[test]:[测试XXXX]&amp;#34; echo &amp;#34;[chore]:[构建/变动XXXX]&amp;#34; echo &amp;#34;[tag]:[版本XXXX]&amp;#34; echo &amp;#34;[revert]:[撤销/回退XXXX]&amp;#34; echo &amp;#34;[perf]:[性能优化XXXX]${no_color}&amp;#34; exit 1 fi pre-commit #!/bin/sh red=&amp;#39;\033[0;31m&amp;#39; green=&amp;#39;\033[0;32m&amp;#39; no_color=&amp;#39;\033[0m&amp;#39; USERNAME=$(git config user.</description></item><item><title>Multiple SSH Keys Settings For Different Git Platform[Github、Gitlab]</title><link>https://coolbeevip.github.io/posts/git/git-multiple-ssh-keys/</link><pubDate>Sun, 22 Aug 2021 13:24:14 +0800</pubDate><guid>https://coolbeevip.github.io/posts/git/git-multiple-ssh-keys/</guid><description>我们在使用 Github、Gitlab 或者 JetBrains Space 时通常使用 SSH 密钥可以连接 Git 服务，而无需在每次访问时都提供用户名和个人访问令牌。 另外现在大量平台启用账户登录多次验证，也促进我们避免使用账号密码登录。
为了便于管理我们通常会为每个 Git 平台配置不同的 SSH KEY，然后通过 ~/.ssh/config 配置每个平台对应的 SSH KEY。
创建多个 SSH KEY 使用如下命令创建 id_github，注意提示输入文件名时请修改成 id_github
ssh-keygen -t ed25519 -C &amp;#34;coolbeevip@github.com&amp;#34; 使用同样的方法我们分别创建 id_gitlab 和 id_github，这时在的本地的 ~/.ssh 目录下会得到如下文件
id_github(私钥)、id_github.pub(公钥) id_gitlab(私钥)、id_gitlab.pub(公钥) 将 *.pub 文件内容分别导入到 Git 服务中，详细方式请参考 Github and SSH keys 、 GitLab and SSH keys 或 JetBrains Space and SSH keys
配置 SSH 编辑 ~/.ssh/config 文件为每个 Git 地址配置不同的私钥
Host github.com ServerAliveInterval 60 UseKeychain yes IdentityFile ~/.</description></item><item><title>GraphQL Tools Schema Parser</title><link>https://coolbeevip.github.io/posts/graphql-tools-schema-paarser-slow/</link><pubDate>Sat, 29 May 2021 13:24:14 +0800</pubDate><guid>https://coolbeevip.github.io/posts/graphql-tools-schema-paarser-slow/</guid><description>SYSTEM
MacBook Pro 16G
JVM
-Xmx4g -Xms4g -Xss256k -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=512m -Xnoclassgc -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:ParallelGCThreads=12 -XX:MaxTenuringThreshold=15 -XX:+ExplicitGCInvokesConcurrent -XX:+CMSParallelRemarkEnabled -XX:SurvivorRatio=8 -XX:CMSInitiatingOccupancyFraction=65 -XX:+UseCMSInitiatingOccupancyOnly -XX:+UseCMSCompactAtFullCollection -XX:+CMSClassUnloadingEnabled -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=10 CPU Flame Graph
GrpaphQL Schema Parser
Slow Method</description></item><item><title>Bash script automates the Maven project Git release process</title><link>https://coolbeevip.github.io/posts/git/git-automate-tag-release-process-with-bash/</link><pubDate>Sun, 16 May 2021 13:24:14 +0800</pubDate><guid>https://coolbeevip.github.io/posts/git/git-automate-tag-release-process-with-bash/</guid><description>开源项目中我们大多采用主干开发模式管理我们的项目，他基本遵循以下规则
所有的 PR 都默认向主干合并 主干上项目的版本号是 -SNAPSHOT 当主干要发布时，我们会建立与之对应的 X 分支（此分支的目的是为了基于此分支发布补丁版本） 基于当前主干去除版本号中的 -SNAPSHOT 后建立与版本对应的 TAG 将主干上的版本号中的 minor 累加一，并在后边增加 -SNAPSHOT 后缀 此过程繁琐，切容易出错。我制作了一个脚本 maven-project-git-release.sh 用来实现这个过程的规范化和自动化
当然，这并不意味着你不需要掌握正手动发布的过程。
由于某种原因导致自动过程中断后，你依然需要手动去处理，所以在使用这个脚本前，请确保你了解这个脚本帮你做了什么工作，以及如何做的。
如何使用 maven-project-git-release.sh 脚本会帮你自动化以下工作
创建一个编译用的目录
目录会创建在你系统的临时目录下，在我的 Mac 系统系统中看起来像 /var/folders/fd/gqdh88px2fj66tmtcy6ffr580000gn/T
在编译用的目录中 git clone 你的仓库代码
你的仓库地址在使用脚本时通过参数指定，像这样 sh maven-project-git-release.sh git@github.com:coolbeevip/license-maven-plugin.git
编译你的代码确保正确
默认在当前仓库根目录下执行 mvn clean package，如果你需要特殊的方式，可以修改脚本中的 check_source_before_release 函数
计算版本号分支名
根据 pom 中的版本定义，自动计算下一版本号，默认采 maven 的3段式版号方式 major.minor.patch，并以此为基准滚动 minor 版本号，如果你需要特殊的方式，可以修改脚本中的 next_version 函数
输出发布计划
发布计划中会显示你要发布的仓库地址，当前版本号、维护用 X 分支、TAG 名称、下一个版本号等信息
Release Plan: ==================================================================== OS: Darwin GIT_REPO_URL: git@github.com:coolbeevip/license-maven-plugin.git RELEASE WORK DIR: /var/folders/fd/gqdh88px2fj66tmtcy6ffr580000gn/T/release-license-maven-plugin.</description></item><item><title>Git Squash Commits</title><link>https://coolbeevip.github.io/posts/git/git-command-commit-squash/</link><pubDate>Mon, 06 Apr 2020 13:24:14 +0800</pubDate><guid>https://coolbeevip.github.io/posts/git/git-command-commit-squash/</guid><description>压缩合并 Commits，将多个 commit 整理合并的方法，这样可以使提交记录更加清晰
查看提交记录，选择你要合并的范围 git log commit 6d757f70af289b5a90d00bd5e4b93d892d64a258 (HEAD -&amp;gt; SCB-1669) Author: Lei Zhang &amp;lt;zhanglei@apache.org&amp;gt; Date: Thu Dec 19 13:53:26 2019 +0800 SCB-1669 Fixed reverse compensation sort bug in FSM commit 37e0c5d99d0e6dae188cbd78f543ba69433b928f (origin/SCB-1669) Author: Lei Zhang &amp;lt;zhanglei@apache.org&amp;gt; Date: Thu Dec 19 02:00:20 2019 +0800 SCB-1669 Fixed Reverse compensation sort bug in FSM commit b4ea8717a86d1eba1956d21727d05c466ff6d8a2 (upstream/master, origin/master, origin/HEAD, master) Author: Lei Zhang &amp;lt;zhanglei@apache.org&amp;gt; Date: Tue Dec 10 16:25:48 2019 +0800 SCB-1658 Improve encapsulation on txEntityMap of SagaData 可以看到最后两次提交，都是为了修复 SCB-1669 这个问题，此时我想合并最后两次提交 6d757f70af289b5a90d00bd5e4b93d892d64a258 和 37e0c5d99d0e6dae188cbd78f543ba69433b928f</description></item><item><title>Git Stash</title><link>https://coolbeevip.github.io/posts/git/git-command-commit-stash/</link><pubDate>Mon, 06 Apr 2020 13:24:14 +0800</pubDate><guid>https://coolbeevip.github.io/posts/git/git-command-commit-stash/</guid><description>你在当前分支上开发代码，此时不想 commit，但是又想切换到其他分支完成其他的工作，此时可以用 stash
在当前分支执行 stash 将当前分支未提交的代码隐藏起来 $ git stash Saved working directory and index state WIP on SCB-1577: 2554be3d SCB-1593 Add notice for Boringssl support ciphers (base) bogon:servicecomb-pack zhanglei$ 此时你可以看到已经存储到一个id为 2554be3d 里了，这时你可以用 git status 查看已经没有要提交的内容了
git status On branch SCB-1577 nothing to commit, working tree clean (base) bogon:servicecomb-pack zhanglei$ 这时你就可以切换到其他分支开始新的工作 (base) bogon:servicecomb-pack zhanglei$ git checkout master Switched to branch &amp;#39;master&amp;#39; Your branch is up to date with &amp;#39;origin/master&amp;#39;. 返回原来的分支继续工作 git checkout SCB-1577 Switched to branch &amp;#39;SCB-1577&amp;#39; 查看以前隐藏的修改内容 git stash list stash@{0}: WIP on SCB-1577: 2554be3d SCB-1593 Add notice for Boringssl support ciphers (base) bogon:servicecomb-pack zhanglei$ 恢复隐藏内容继续工作，使用 git stash apply {id} (base) bogon:servicecomb-pack zhanglei$ git stash apply stash@{0} On branch SCB-1577 Changes not staged for commit: (use &amp;#34;git add &amp;lt;file&amp;gt;.</description></item><item><title>Synchronizing Your Forked Git Project</title><link>https://coolbeevip.github.io/posts/git/git-command-rebase-upstream/</link><pubDate>Mon, 06 Apr 2020 13:24:14 +0800</pubDate><guid>https://coolbeevip.github.io/posts/git/git-command-rebase-upstream/</guid><description>当你 fork 一个仓库后，可以时用此方法使你 fork 后的仓库 master 分支保持和上游 master 分支的同步
使用 rebase 命令同步上游 master 分支到你本地的 master 分支，并推送到你 fork 后的仓库
git fetch upstream git checkout master git rebase upstream/master git push -f origin master 或者你确定放弃你本地所有的修改，则可以简单的重置为上游版本
git fetch upstream git checkout master git reset --hard upstream/master git push -f origin master 如果你也想同步 master 分支的修改到你的功能分支
git checkout &amp;lt;分支名&amp;gt; git rebase master git push -f origin &amp;lt;分支名&amp;gt;</description></item><item><title>Git Reset HEAD</title><link>https://coolbeevip.github.io/posts/git/git-reset-head/</link><pubDate>Tue, 06 Aug 2019 13:24:14 +0800</pubDate><guid>https://coolbeevip.github.io/posts/git/git-reset-head/</guid><description>Git 分支非常有用，您可以根据需要创建一个新分支，合并一个分支或删除一个分支。 您可以使用许多 git 命令来管理 git 中的分支。
当您使用 git checkout 分支时，HEAD会指出最后的提交。 简单来说，您可以说 Git HEAD 是当前分支。 每当您签出一个分支或创建一个新分支时，Git HEAD 都会转移它。
HEAD 是对当前检出分支中最后一次提交的引用。
在存储库中，HEAD 始终指向当前分支的起点。 换句话说，HEAD 是指向下一个提交的父对象或下一个提交将发生的地方的指针。
更具体地说，HEAD 是一个移动指针，它可以引用或可以不引用当前分支，但是它始终引用当前提交。
什么是 HEAD^ 插入符（^）是 Commit 的父级。
什么是 HEAD~ 代字号（〜）是一行几个字符（^）的简写字符。
HEAD〜2 与 HEAD ^^ 的作用相同。
如果写数字，则使用的默认值为1，因此 HEAD〜 等价于 HEAD ^。
如何检查HEAD的状态 您可以使用以下命令查看当前 Git HEAD 指向的位置：
$ cat .git/HEAD ref: refs/heads/master 并且，你可以使用以下命令查看指向 HEAD 的 commit 的 Hash ID：
$ git rev-parse --short HEAD 6f975a5 Detached HEAD HEAD 是您目前的工作分支。 当您尝试 git checkout 分支时，HEAD 指向该分支的顶部，这样您就可以继续工作而没有任何困难。</description></item><item><title>Git Revert</title><link>https://coolbeevip.github.io/posts/git/git-command-revert/</link><pubDate>Tue, 06 Aug 2019 13:24:14 +0800</pubDate><guid>https://coolbeevip.github.io/posts/git/git-command-revert/</guid><description>撤销上一次提交
$ git revert HEAD 撤销上两次提交
ISSUE-4 解决网关服务日志中无法正确显示经过代理访问的请求端 IP 问题 $ git revert [倒数第一个提交] [倒数第二个提交]</description></item><item><title>Git Commands</title><link>https://coolbeevip.github.io/posts/git/git-commands/</link><pubDate>Sat, 06 Apr 2019 13:24:14 +0800</pubDate><guid>https://coolbeevip.github.io/posts/git/git-commands/</guid><description>常用 Git 命令
Init 在已有目录中初始化 GIT 仓库
$ git init $ git remote add origin &amp;lt;仓库地址&amp;gt; $ git add . $ git commit -m &amp;#34;Initial commit&amp;#34; $ git push -u origin master Branch 创建分支
git checkout -b &amp;lt;分支名&amp;gt; 推送分支
git push origin &amp;lt;分支名&amp;gt; 修改分支名
git branch -m &amp;lt;旧分支名&amp;gt; &amp;lt;新分支名&amp;gt; 删除本地分支
git branch -D &amp;lt;分支名&amp;gt; 删除远程分支
git push origin --delete &amp;lt;分支名&amp;gt; 拉取远程分支
git fetch origin &amp;lt;分支名&amp;gt; 拉取远程分支并切换
git checkout -b &amp;lt;分支名&amp;gt; origin/&amp;lt;分支名&amp;gt; 当前分支会退到指定版本</description></item></channel></rss>