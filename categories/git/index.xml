<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>git on</title><link>https://coolbeevip.github.io/categories/git/</link><description>Recent content in git on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 02 Apr 2022 13:24:14 +0800</lastBuildDate><atom:link href="https://coolbeevip.github.io/categories/git/index.xml" rel="self" type="application/rss+xml"/><item><title>Awesome Git Aliases</title><link>https://coolbeevip.github.io/posts/git/git-awesome-aliases/</link><pubDate>Sat, 02 Apr 2022 13:24:14 +0800</pubDate><guid>https://coolbeevip.github.io/posts/git/git-awesome-aliases/</guid><description>我们可以通过别名定义简化命令输出，创造自己的命令
打开 ~/.gitconfig 文件您可以看到如下片段，在这个片段中我们可以为已有命令定义别名
[alias] 例如我们创建分支是需要使用 git branch -b xxx 命令，那么我们可以将 branch 简化为 br。我们只需要增加如下配置
[alias] br = branch 这是我自己常用的配置
[alias] ci = commit -a co = checkout cl = clone st = status br = branch mr = merge cp = cherry-pick hist = log --pretty=format:\&amp;#34;%h %ad | %s%d [%an]\&amp;#34; --graph --date=short type = cat-file -t dump = cat-file -p sync-up = !git fetch upstream &amp;amp;&amp;amp; git checkout $1 &amp;amp;&amp;amp; git rebase upstream/$1 &amp;amp;&amp;amp; git push origin $1 &amp;amp;&amp;amp; :</description></item><item><title>Multiple SSH Keys Settings For Different Git Platform[Github、Gitlab]</title><link>https://coolbeevip.github.io/posts/git/git-multiple-ssh-keys/</link><pubDate>Sun, 22 Aug 2021 13:24:14 +0800</pubDate><guid>https://coolbeevip.github.io/posts/git/git-multiple-ssh-keys/</guid><description>我们在使用 Github、Gitlab 或者 JetBrains Space 时通常使用 SSH 密钥可以连接 Git 服务，而无需在每次访问时都提供用户名和个人访问令牌。 另外现在大量平台启用账户登录多次验证，也促进我们避免使用账号密码登录。
为了便于管理我们通常会为每个 Git 平台配置不同的 SSH KEY，然后通过 ~/.ssh/config 配置每个平台对应的 SSH KEY。
创建多个 SSH KEY 使用如下命令创建 id_github，注意提示输入文件名时请修改成 id_github
ssh-keygen -t ed25519 -C &amp;#34;coolbeevip@github.com&amp;#34; 使用同样的方法我们分别创建 id_gitlab 和 id_github，这时在的本地的 ~/.ssh 目录下会得到如下文件
id_github(私钥)、id_github.pub(公钥) id_gitlab(私钥)、id_gitlab.pub(公钥) 将 *.pub 文件内容分别导入到 Git 服务中，详细方式请参考 Github and SSH keys 、 GitLab and SSH keys 或 JetBrains Space and SSH keys
配置 SSH 编辑 ~/.ssh/config 文件为每个 Git 地址配置不同的私钥
Host github.com ServerAliveInterval 60 UseKeychain yes IdentityFile ~/.</description></item><item><title>GraphQL Tools Schema Parser</title><link>https://coolbeevip.github.io/posts/graphql-tools-schema-paarser-slow/</link><pubDate>Sat, 29 May 2021 13:24:14 +0800</pubDate><guid>https://coolbeevip.github.io/posts/graphql-tools-schema-paarser-slow/</guid><description>SYSTEM
MacBook Pro 16G
JVM
-Xmx4g -Xms4g -Xss256k -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=512m -Xnoclassgc -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:ParallelGCThreads=12 -XX:MaxTenuringThreshold=15 -XX:+ExplicitGCInvokesConcurrent -XX:+CMSParallelRemarkEnabled -XX:SurvivorRatio=8 -XX:CMSInitiatingOccupancyFraction=65 -XX:+UseCMSInitiatingOccupancyOnly -XX:+UseCMSCompactAtFullCollection -XX:+CMSClassUnloadingEnabled -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=10 CPU Flame Graph
GrpaphQL Schema Parser
Slow Method</description></item><item><title>Bash script automates the Maven project Git release process</title><link>https://coolbeevip.github.io/posts/git/git-automate-tag-release-process-with-bash/</link><pubDate>Sun, 16 May 2021 13:24:14 +0800</pubDate><guid>https://coolbeevip.github.io/posts/git/git-automate-tag-release-process-with-bash/</guid><description>开源项目中我们大多采用主干开发模式管理我们的项目，他基本遵循以下规则
所有的 PR 都默认向主干合并 主干上项目的版本号是 -SNAPSHOT 当主干要发布时，我们会建立与之对应的 X 分支（此分支的目的是为了基于此分支发布补丁版本） 基于当前主干去除版本号中的 -SNAPSHOT 后建立与版本对应的 TAG 将主干上的版本号中的 minor 累加一，并在后边增加 -SNAPSHOT 后缀 此过程繁琐，切容易出错。我制作了一个脚本 maven-project-git-release.sh 用来实现这个过程的规范化和自动化
当然，这并不意味着你不需要掌握正手动发布的过程。
由于某种原因导致自动过程中断后，你依然需要手动去处理，所以在使用这个脚本前，请确保你了解这个脚本帮你做了什么工作，以及如何做的。
如何使用 maven-project-git-release.sh 脚本会帮你自动化以下工作
创建一个编译用的目录
目录会创建在你系统的临时目录下，在我的 Mac 系统系统中看起来像 /var/folders/fd/gqdh88px2fj66tmtcy6ffr580000gn/T
在编译用的目录中 git clone 你的仓库代码
你的仓库地址在使用脚本时通过参数指定，像这样 sh maven-project-git-release.sh git@github.com:coolbeevip/license-maven-plugin.git
编译你的代码确保正确
默认在当前仓库根目录下执行 mvn clean package，如果你需要特殊的方式，可以修改脚本中的 check_source_before_release 函数
计算版本号分支名
根据 pom 中的版本定义，自动计算下一版本号，默认采 maven 的3段式版号方式 major.minor.patch，并以此为基准滚动 minor 版本号，如果你需要特殊的方式，可以修改脚本中的 next_version 函数
输出发布计划
发布计划中会显示你要发布的仓库地址，当前版本号、维护用 X 分支、TAG 名称、下一个版本号等信息
Release Plan: ==================================================================== OS: Darwin GIT_REPO_URL: git@github.com:coolbeevip/license-maven-plugin.git RELEASE WORK DIR: /var/folders/fd/gqdh88px2fj66tmtcy6ffr580000gn/T/release-license-maven-plugin.</description></item><item><title>Git Squash Commits</title><link>https://coolbeevip.github.io/posts/git/git-command-commit-squash/</link><pubDate>Mon, 06 Apr 2020 13:24:14 +0800</pubDate><guid>https://coolbeevip.github.io/posts/git/git-command-commit-squash/</guid><description>压缩合并 Commits，将多个 commit 整理合并的方法，这样可以使提交记录更加清晰
查看提交记录，选择你要合并的范围 git log commit 6d757f70af289b5a90d00bd5e4b93d892d64a258 (HEAD -&amp;gt; SCB-1669) Author: Lei Zhang &amp;lt;zhanglei@apache.org&amp;gt; Date: Thu Dec 19 13:53:26 2019 +0800 SCB-1669 Fixed reverse compensation sort bug in FSM commit 37e0c5d99d0e6dae188cbd78f543ba69433b928f (origin/SCB-1669) Author: Lei Zhang &amp;lt;zhanglei@apache.org&amp;gt; Date: Thu Dec 19 02:00:20 2019 +0800 SCB-1669 Fixed Reverse compensation sort bug in FSM commit b4ea8717a86d1eba1956d21727d05c466ff6d8a2 (upstream/master, origin/master, origin/HEAD, master) Author: Lei Zhang &amp;lt;zhanglei@apache.org&amp;gt; Date: Tue Dec 10 16:25:48 2019 +0800 SCB-1658 Improve encapsulation on txEntityMap of SagaData 可以看到最后两次提交，都是为了修复 SCB-1669 这个问题，此时我想合并最后两次提交 6d757f70af289b5a90d00bd5e4b93d892d64a258 和 37e0c5d99d0e6dae188cbd78f543ba69433b928f</description></item><item><title>Git Stash</title><link>https://coolbeevip.github.io/posts/git/git-command-commit-stash/</link><pubDate>Mon, 06 Apr 2020 13:24:14 +0800</pubDate><guid>https://coolbeevip.github.io/posts/git/git-command-commit-stash/</guid><description>你在当前分支上开发代码，此时不想 commit，但是又想切换到其他分支完成其他的工作，此时可以用 stash
在当前分支执行 stash 将当前分支未提交的代码隐藏起来 $ git stash Saved working directory and index state WIP on SCB-1577: 2554be3d SCB-1593 Add notice for Boringssl support ciphers (base) bogon:servicecomb-pack zhanglei$ 此时你可以看到已经存储到一个id为 2554be3d 里了，这时你可以用 git status 查看已经没有要提交的内容了
git status On branch SCB-1577 nothing to commit, working tree clean (base) bogon:servicecomb-pack zhanglei$ 这时你就可以切换到其他分支开始新的工作 (base) bogon:servicecomb-pack zhanglei$ git checkout master Switched to branch &amp;#39;master&amp;#39; Your branch is up to date with &amp;#39;origin/master&amp;#39;. 返回原来的分支继续工作 git checkout SCB-1577 Switched to branch &amp;#39;SCB-1577&amp;#39; 查看以前隐藏的修改内容 git stash list stash@{0}: WIP on SCB-1577: 2554be3d SCB-1593 Add notice for Boringssl support ciphers (base) bogon:servicecomb-pack zhanglei$ 恢复隐藏内容继续工作，使用 git stash apply {id} (base) bogon:servicecomb-pack zhanglei$ git stash apply stash@{0} On branch SCB-1577 Changes not staged for commit: (use &amp;#34;git add &amp;lt;file&amp;gt;.</description></item><item><title>Synchronizing Your Forked Git Project</title><link>https://coolbeevip.github.io/posts/git/git-command-rebase-upstream/</link><pubDate>Mon, 06 Apr 2020 13:24:14 +0800</pubDate><guid>https://coolbeevip.github.io/posts/git/git-command-rebase-upstream/</guid><description>当你 fork 一个仓库后，可以时用此方法使你 fork 后的仓库 master 分支保持和上游 master 分支的同步
使用 rebase 命令同步上游 master 分支到你本地的 master 分支，并推送到你 fork 后的仓库
git fetch upstream git checkout master git rebase upstream/master git push -f origin master 或者你确定放弃你本地所有的修改，则可以简单的重置为上游版本
git fetch upstream git checkout master git reset --hard upstream/master git push -f origin master 如果你也想同步 master 分支的修改到你的功能分支
git checkout &amp;lt;分支名&amp;gt; git rebase master git push -f origin &amp;lt;分支名&amp;gt;</description></item><item><title>Git Reset HEAD</title><link>https://coolbeevip.github.io/posts/git/git-reset-head/</link><pubDate>Tue, 06 Aug 2019 13:24:14 +0800</pubDate><guid>https://coolbeevip.github.io/posts/git/git-reset-head/</guid><description>Git 分支非常有用，您可以根据需要创建一个新分支，合并一个分支或删除一个分支。 您可以使用许多 git 命令来管理 git 中的分支。
当您使用 git checkout 分支时，HEAD会指出最后的提交。 简单来说，您可以说 Git HEAD 是当前分支。 每当您签出一个分支或创建一个新分支时，Git HEAD 都会转移它。
HEAD 是对当前检出分支中最后一次提交的引用。
在存储库中，HEAD 始终指向当前分支的起点。 换句话说，HEAD 是指向下一个提交的父对象或下一个提交将发生的地方的指针。
更具体地说，HEAD 是一个移动指针，它可以引用或可以不引用当前分支，但是它始终引用当前提交。
什么是 HEAD^ 插入符（^）是 Commit 的父级。
什么是 HEAD~ 代字号（〜）是一行几个字符（^）的简写字符。
HEAD〜2 与 HEAD ^^ 的作用相同。
如果写数字，则使用的默认值为1，因此 HEAD〜 等价于 HEAD ^。
如何检查HEAD的状态 您可以使用以下命令查看当前 Git HEAD 指向的位置：
$ cat .git/HEAD ref: refs/heads/master 并且，你可以使用以下命令查看指向 HEAD 的 commit 的 Hash ID：
$ git rev-parse --short HEAD 6f975a5 Detached HEAD HEAD 是您目前的工作分支。 当您尝试 git checkout 分支时，HEAD 指向该分支的顶部，这样您就可以继续工作而没有任何困难。</description></item><item><title>Git Revert</title><link>https://coolbeevip.github.io/posts/git/git-command-revert/</link><pubDate>Tue, 06 Aug 2019 13:24:14 +0800</pubDate><guid>https://coolbeevip.github.io/posts/git/git-command-revert/</guid><description>撤销上一次提交
$ git revert HEAD 撤销上两次提交
ISSUE-4 解决网关服务日志中无法正确显示经过代理访问的请求端 IP 问题 $ git revert [倒数第一个提交] [倒数第二个提交]</description></item><item><title>Git Commands</title><link>https://coolbeevip.github.io/posts/git/git-commands/</link><pubDate>Sat, 06 Apr 2019 13:24:14 +0800</pubDate><guid>https://coolbeevip.github.io/posts/git/git-commands/</guid><description>常用 Git 命令
Init 在已有目录中初始化 GIT 仓库
$ git init $ git remote add origin &amp;lt;仓库地址&amp;gt; $ git add . $ git commit -m &amp;#34;Initial commit&amp;#34; $ git push -u origin master Branch 创建分支
git checkout -b &amp;lt;分支名&amp;gt; 推送分支
git push origin &amp;lt;分支名&amp;gt; 修改分支名
git branch -m &amp;lt;旧分支名&amp;gt; &amp;lt;新分支名&amp;gt; 删除本地分支
git branch -D &amp;lt;分支名&amp;gt; 删除远程分支
git push origin --delete &amp;lt;分支名&amp;gt; 拉取远程分支
git fetch origin &amp;lt;分支名&amp;gt; 拉取远程分支并切换
git checkout -b &amp;lt;分支名&amp;gt; origin/&amp;lt;分支名&amp;gt; 当前分支会退到指定版本</description></item></channel></rss>